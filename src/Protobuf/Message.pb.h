// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Message.proto

#ifndef PROTOBUF_Message_2eproto__INCLUDED
#define PROTOBUF_Message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace msg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Message_2eproto();
void protobuf_AssignDesc_Message_2eproto();
void protobuf_ShutdownFile_Message_2eproto();

class PingResponse;
class Command;
class AddCommandsRequest;
class GetCommandsResponse;
class ExeCommandRequest;
class FileUpload;
class Message;

// ===================================================================

class PingResponse : public ::google::protobuf::Message {
 public:
  PingResponse();
  virtual ~PingResponse();

  PingResponse(const PingResponse& from);

  inline PingResponse& operator=(const PingResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PingResponse& default_instance();

  void Swap(PingResponse* other);

  // implements Message ----------------------------------------------

  PingResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PingResponse& from);
  void MergeFrom(const PingResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 t = 1;
  inline bool has_t() const;
  inline void clear_t();
  static const int kTFieldNumber = 1;
  inline ::google::protobuf::uint32 t() const;
  inline void set_t(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:msg.PingResponse)
 private:
  inline void set_has_t();
  inline void clear_has_t();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 t_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static PingResponse* default_instance_;
};
// -------------------------------------------------------------------

class Command : public ::google::protobuf::Message {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();

  void Swap(Command* other);

  // implements Message ----------------------------------------------

  Command* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string commandname = 1;
  inline bool has_commandname() const;
  inline void clear_commandname();
  static const int kCommandnameFieldNumber = 1;
  inline const ::std::string& commandname() const;
  inline void set_commandname(const ::std::string& value);
  inline void set_commandname(const char* value);
  inline void set_commandname(const char* value, size_t size);
  inline ::std::string* mutable_commandname();
  inline ::std::string* release_commandname();
  inline void set_allocated_commandname(::std::string* commandname);

  // required string filepath = 2;
  inline bool has_filepath() const;
  inline void clear_filepath();
  static const int kFilepathFieldNumber = 2;
  inline const ::std::string& filepath() const;
  inline void set_filepath(const ::std::string& value);
  inline void set_filepath(const char* value);
  inline void set_filepath(const char* value, size_t size);
  inline ::std::string* mutable_filepath();
  inline ::std::string* release_filepath();
  inline void set_allocated_filepath(::std::string* filepath);

  // required string funcname = 3;
  inline bool has_funcname() const;
  inline void clear_funcname();
  static const int kFuncnameFieldNumber = 3;
  inline const ::std::string& funcname() const;
  inline void set_funcname(const ::std::string& value);
  inline void set_funcname(const char* value);
  inline void set_funcname(const char* value, size_t size);
  inline ::std::string* mutable_funcname();
  inline ::std::string* release_funcname();
  inline void set_allocated_funcname(::std::string* funcname);

  // required string commandhelp = 4;
  inline bool has_commandhelp() const;
  inline void clear_commandhelp();
  static const int kCommandhelpFieldNumber = 4;
  inline const ::std::string& commandhelp() const;
  inline void set_commandhelp(const ::std::string& value);
  inline void set_commandhelp(const char* value);
  inline void set_commandhelp(const char* value, size_t size);
  inline ::std::string* mutable_commandhelp();
  inline ::std::string* release_commandhelp();
  inline void set_allocated_commandhelp(::std::string* commandhelp);

  // @@protoc_insertion_point(class_scope:msg.Command)
 private:
  inline void set_has_commandname();
  inline void clear_has_commandname();
  inline void set_has_filepath();
  inline void clear_has_filepath();
  inline void set_has_funcname();
  inline void clear_has_funcname();
  inline void set_has_commandhelp();
  inline void clear_has_commandhelp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* commandname_;
  ::std::string* filepath_;
  ::std::string* funcname_;
  ::std::string* commandhelp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static Command* default_instance_;
};
// -------------------------------------------------------------------

class AddCommandsRequest : public ::google::protobuf::Message {
 public:
  AddCommandsRequest();
  virtual ~AddCommandsRequest();

  AddCommandsRequest(const AddCommandsRequest& from);

  inline AddCommandsRequest& operator=(const AddCommandsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddCommandsRequest& default_instance();

  void Swap(AddCommandsRequest* other);

  // implements Message ----------------------------------------------

  AddCommandsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddCommandsRequest& from);
  void MergeFrom(const AddCommandsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .msg.Command command = 1;
  inline int command_size() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline const ::msg::Command& command(int index) const;
  inline ::msg::Command* mutable_command(int index);
  inline ::msg::Command* add_command();
  inline const ::google::protobuf::RepeatedPtrField< ::msg::Command >&
      command() const;
  inline ::google::protobuf::RepeatedPtrField< ::msg::Command >*
      mutable_command();

  // @@protoc_insertion_point(class_scope:msg.AddCommandsRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::msg::Command > command_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AddCommandsRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetCommandsResponse : public ::google::protobuf::Message {
 public:
  GetCommandsResponse();
  virtual ~GetCommandsResponse();

  GetCommandsResponse(const GetCommandsResponse& from);

  inline GetCommandsResponse& operator=(const GetCommandsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetCommandsResponse& default_instance();

  void Swap(GetCommandsResponse* other);

  // implements Message ----------------------------------------------

  GetCommandsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetCommandsResponse& from);
  void MergeFrom(const GetCommandsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .msg.Command command = 1;
  inline int command_size() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline const ::msg::Command& command(int index) const;
  inline ::msg::Command* mutable_command(int index);
  inline ::msg::Command* add_command();
  inline const ::google::protobuf::RepeatedPtrField< ::msg::Command >&
      command() const;
  inline ::google::protobuf::RepeatedPtrField< ::msg::Command >*
      mutable_command();

  // @@protoc_insertion_point(class_scope:msg.GetCommandsResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::msg::Command > command_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GetCommandsResponse* default_instance_;
};
// -------------------------------------------------------------------

class ExeCommandRequest : public ::google::protobuf::Message {
 public:
  ExeCommandRequest();
  virtual ~ExeCommandRequest();

  ExeCommandRequest(const ExeCommandRequest& from);

  inline ExeCommandRequest& operator=(const ExeCommandRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExeCommandRequest& default_instance();

  void Swap(ExeCommandRequest* other);

  // implements Message ----------------------------------------------

  ExeCommandRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExeCommandRequest& from);
  void MergeFrom(const ExeCommandRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string commandname = 1;
  inline bool has_commandname() const;
  inline void clear_commandname();
  static const int kCommandnameFieldNumber = 1;
  inline const ::std::string& commandname() const;
  inline void set_commandname(const ::std::string& value);
  inline void set_commandname(const char* value);
  inline void set_commandname(const char* value, size_t size);
  inline ::std::string* mutable_commandname();
  inline ::std::string* release_commandname();
  inline void set_allocated_commandname(::std::string* commandname);

  // @@protoc_insertion_point(class_scope:msg.ExeCommandRequest)
 private:
  inline void set_has_commandname();
  inline void clear_has_commandname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* commandname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ExeCommandRequest* default_instance_;
};
// -------------------------------------------------------------------

class FileUpload : public ::google::protobuf::Message {
 public:
  FileUpload();
  virtual ~FileUpload();

  FileUpload(const FileUpload& from);

  inline FileUpload& operator=(const FileUpload& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FileUpload& default_instance();

  void Swap(FileUpload* other);

  // implements Message ----------------------------------------------

  FileUpload* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileUpload& from);
  void MergeFrom(const FileUpload& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string filepath = 1;
  inline bool has_filepath() const;
  inline void clear_filepath();
  static const int kFilepathFieldNumber = 1;
  inline const ::std::string& filepath() const;
  inline void set_filepath(const ::std::string& value);
  inline void set_filepath(const char* value);
  inline void set_filepath(const char* value, size_t size);
  inline ::std::string* mutable_filepath();
  inline ::std::string* release_filepath();
  inline void set_allocated_filepath(::std::string* filepath);

  // required uint64 filepos = 2;
  inline bool has_filepos() const;
  inline void clear_filepos();
  static const int kFileposFieldNumber = 2;
  inline ::google::protobuf::uint64 filepos() const;
  inline void set_filepos(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:msg.FileUpload)
 private:
  inline void set_has_filepath();
  inline void clear_has_filepath();
  inline void set_has_filepos();
  inline void clear_has_filepos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* filepath_;
  ::google::protobuf::uint64 filepos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static FileUpload* default_instance_;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .msg.AddCommandsRequest acr = 1;
  inline bool has_acr() const;
  inline void clear_acr();
  static const int kAcrFieldNumber = 1;
  inline const ::msg::AddCommandsRequest& acr() const;
  inline ::msg::AddCommandsRequest* mutable_acr();
  inline ::msg::AddCommandsRequest* release_acr();
  inline void set_allocated_acr(::msg::AddCommandsRequest* acr);

  // optional .msg.GetCommandsResponse gcr = 2;
  inline bool has_gcr() const;
  inline void clear_gcr();
  static const int kGcrFieldNumber = 2;
  inline const ::msg::GetCommandsResponse& gcr() const;
  inline ::msg::GetCommandsResponse* mutable_gcr();
  inline ::msg::GetCommandsResponse* release_gcr();
  inline void set_allocated_gcr(::msg::GetCommandsResponse* gcr);

  // optional .msg.ExeCommandRequest ecr = 3;
  inline bool has_ecr() const;
  inline void clear_ecr();
  static const int kEcrFieldNumber = 3;
  inline const ::msg::ExeCommandRequest& ecr() const;
  inline ::msg::ExeCommandRequest* mutable_ecr();
  inline ::msg::ExeCommandRequest* release_ecr();
  inline void set_allocated_ecr(::msg::ExeCommandRequest* ecr);

  // optional .msg.FileUpload fu = 4;
  inline bool has_fu() const;
  inline void clear_fu();
  static const int kFuFieldNumber = 4;
  inline const ::msg::FileUpload& fu() const;
  inline ::msg::FileUpload* mutable_fu();
  inline ::msg::FileUpload* release_fu();
  inline void set_allocated_fu(::msg::FileUpload* fu);

  // @@protoc_insertion_point(class_scope:msg.Message)
 private:
  inline void set_has_acr();
  inline void clear_has_acr();
  inline void set_has_gcr();
  inline void clear_has_gcr();
  inline void set_has_ecr();
  inline void clear_has_ecr();
  inline void set_has_fu();
  inline void clear_has_fu();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::msg::AddCommandsRequest* acr_;
  ::msg::GetCommandsResponse* gcr_;
  ::msg::ExeCommandRequest* ecr_;
  ::msg::FileUpload* fu_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// ===================================================================


// ===================================================================

// PingResponse

// required uint32 t = 1;
inline bool PingResponse::has_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PingResponse::set_has_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PingResponse::clear_has_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PingResponse::clear_t() {
  t_ = 0u;
  clear_has_t();
}
inline ::google::protobuf::uint32 PingResponse::t() const {
  return t_;
}
inline void PingResponse::set_t(::google::protobuf::uint32 value) {
  set_has_t();
  t_ = value;
}

// -------------------------------------------------------------------

// Command

// required string commandname = 1;
inline bool Command::has_commandname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command::set_has_commandname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command::clear_has_commandname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command::clear_commandname() {
  if (commandname_ != &::google::protobuf::internal::kEmptyString) {
    commandname_->clear();
  }
  clear_has_commandname();
}
inline const ::std::string& Command::commandname() const {
  return *commandname_;
}
inline void Command::set_commandname(const ::std::string& value) {
  set_has_commandname();
  if (commandname_ == &::google::protobuf::internal::kEmptyString) {
    commandname_ = new ::std::string;
  }
  commandname_->assign(value);
}
inline void Command::set_commandname(const char* value) {
  set_has_commandname();
  if (commandname_ == &::google::protobuf::internal::kEmptyString) {
    commandname_ = new ::std::string;
  }
  commandname_->assign(value);
}
inline void Command::set_commandname(const char* value, size_t size) {
  set_has_commandname();
  if (commandname_ == &::google::protobuf::internal::kEmptyString) {
    commandname_ = new ::std::string;
  }
  commandname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command::mutable_commandname() {
  set_has_commandname();
  if (commandname_ == &::google::protobuf::internal::kEmptyString) {
    commandname_ = new ::std::string;
  }
  return commandname_;
}
inline ::std::string* Command::release_commandname() {
  clear_has_commandname();
  if (commandname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = commandname_;
    commandname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command::set_allocated_commandname(::std::string* commandname) {
  if (commandname_ != &::google::protobuf::internal::kEmptyString) {
    delete commandname_;
  }
  if (commandname) {
    set_has_commandname();
    commandname_ = commandname;
  } else {
    clear_has_commandname();
    commandname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string filepath = 2;
inline bool Command::has_filepath() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command::set_has_filepath() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command::clear_has_filepath() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command::clear_filepath() {
  if (filepath_ != &::google::protobuf::internal::kEmptyString) {
    filepath_->clear();
  }
  clear_has_filepath();
}
inline const ::std::string& Command::filepath() const {
  return *filepath_;
}
inline void Command::set_filepath(const ::std::string& value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
}
inline void Command::set_filepath(const char* value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
}
inline void Command::set_filepath(const char* value, size_t size) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command::mutable_filepath() {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  return filepath_;
}
inline ::std::string* Command::release_filepath() {
  clear_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filepath_;
    filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command::set_allocated_filepath(::std::string* filepath) {
  if (filepath_ != &::google::protobuf::internal::kEmptyString) {
    delete filepath_;
  }
  if (filepath) {
    set_has_filepath();
    filepath_ = filepath;
  } else {
    clear_has_filepath();
    filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string funcname = 3;
inline bool Command::has_funcname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Command::set_has_funcname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Command::clear_has_funcname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Command::clear_funcname() {
  if (funcname_ != &::google::protobuf::internal::kEmptyString) {
    funcname_->clear();
  }
  clear_has_funcname();
}
inline const ::std::string& Command::funcname() const {
  return *funcname_;
}
inline void Command::set_funcname(const ::std::string& value) {
  set_has_funcname();
  if (funcname_ == &::google::protobuf::internal::kEmptyString) {
    funcname_ = new ::std::string;
  }
  funcname_->assign(value);
}
inline void Command::set_funcname(const char* value) {
  set_has_funcname();
  if (funcname_ == &::google::protobuf::internal::kEmptyString) {
    funcname_ = new ::std::string;
  }
  funcname_->assign(value);
}
inline void Command::set_funcname(const char* value, size_t size) {
  set_has_funcname();
  if (funcname_ == &::google::protobuf::internal::kEmptyString) {
    funcname_ = new ::std::string;
  }
  funcname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command::mutable_funcname() {
  set_has_funcname();
  if (funcname_ == &::google::protobuf::internal::kEmptyString) {
    funcname_ = new ::std::string;
  }
  return funcname_;
}
inline ::std::string* Command::release_funcname() {
  clear_has_funcname();
  if (funcname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = funcname_;
    funcname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command::set_allocated_funcname(::std::string* funcname) {
  if (funcname_ != &::google::protobuf::internal::kEmptyString) {
    delete funcname_;
  }
  if (funcname) {
    set_has_funcname();
    funcname_ = funcname;
  } else {
    clear_has_funcname();
    funcname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string commandhelp = 4;
inline bool Command::has_commandhelp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Command::set_has_commandhelp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Command::clear_has_commandhelp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Command::clear_commandhelp() {
  if (commandhelp_ != &::google::protobuf::internal::kEmptyString) {
    commandhelp_->clear();
  }
  clear_has_commandhelp();
}
inline const ::std::string& Command::commandhelp() const {
  return *commandhelp_;
}
inline void Command::set_commandhelp(const ::std::string& value) {
  set_has_commandhelp();
  if (commandhelp_ == &::google::protobuf::internal::kEmptyString) {
    commandhelp_ = new ::std::string;
  }
  commandhelp_->assign(value);
}
inline void Command::set_commandhelp(const char* value) {
  set_has_commandhelp();
  if (commandhelp_ == &::google::protobuf::internal::kEmptyString) {
    commandhelp_ = new ::std::string;
  }
  commandhelp_->assign(value);
}
inline void Command::set_commandhelp(const char* value, size_t size) {
  set_has_commandhelp();
  if (commandhelp_ == &::google::protobuf::internal::kEmptyString) {
    commandhelp_ = new ::std::string;
  }
  commandhelp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command::mutable_commandhelp() {
  set_has_commandhelp();
  if (commandhelp_ == &::google::protobuf::internal::kEmptyString) {
    commandhelp_ = new ::std::string;
  }
  return commandhelp_;
}
inline ::std::string* Command::release_commandhelp() {
  clear_has_commandhelp();
  if (commandhelp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = commandhelp_;
    commandhelp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command::set_allocated_commandhelp(::std::string* commandhelp) {
  if (commandhelp_ != &::google::protobuf::internal::kEmptyString) {
    delete commandhelp_;
  }
  if (commandhelp) {
    set_has_commandhelp();
    commandhelp_ = commandhelp;
  } else {
    clear_has_commandhelp();
    commandhelp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AddCommandsRequest

// repeated .msg.Command command = 1;
inline int AddCommandsRequest::command_size() const {
  return command_.size();
}
inline void AddCommandsRequest::clear_command() {
  command_.Clear();
}
inline const ::msg::Command& AddCommandsRequest::command(int index) const {
  return command_.Get(index);
}
inline ::msg::Command* AddCommandsRequest::mutable_command(int index) {
  return command_.Mutable(index);
}
inline ::msg::Command* AddCommandsRequest::add_command() {
  return command_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::msg::Command >&
AddCommandsRequest::command() const {
  return command_;
}
inline ::google::protobuf::RepeatedPtrField< ::msg::Command >*
AddCommandsRequest::mutable_command() {
  return &command_;
}

// -------------------------------------------------------------------

// GetCommandsResponse

// repeated .msg.Command command = 1;
inline int GetCommandsResponse::command_size() const {
  return command_.size();
}
inline void GetCommandsResponse::clear_command() {
  command_.Clear();
}
inline const ::msg::Command& GetCommandsResponse::command(int index) const {
  return command_.Get(index);
}
inline ::msg::Command* GetCommandsResponse::mutable_command(int index) {
  return command_.Mutable(index);
}
inline ::msg::Command* GetCommandsResponse::add_command() {
  return command_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::msg::Command >&
GetCommandsResponse::command() const {
  return command_;
}
inline ::google::protobuf::RepeatedPtrField< ::msg::Command >*
GetCommandsResponse::mutable_command() {
  return &command_;
}

// -------------------------------------------------------------------

// ExeCommandRequest

// required string commandname = 1;
inline bool ExeCommandRequest::has_commandname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExeCommandRequest::set_has_commandname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExeCommandRequest::clear_has_commandname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExeCommandRequest::clear_commandname() {
  if (commandname_ != &::google::protobuf::internal::kEmptyString) {
    commandname_->clear();
  }
  clear_has_commandname();
}
inline const ::std::string& ExeCommandRequest::commandname() const {
  return *commandname_;
}
inline void ExeCommandRequest::set_commandname(const ::std::string& value) {
  set_has_commandname();
  if (commandname_ == &::google::protobuf::internal::kEmptyString) {
    commandname_ = new ::std::string;
  }
  commandname_->assign(value);
}
inline void ExeCommandRequest::set_commandname(const char* value) {
  set_has_commandname();
  if (commandname_ == &::google::protobuf::internal::kEmptyString) {
    commandname_ = new ::std::string;
  }
  commandname_->assign(value);
}
inline void ExeCommandRequest::set_commandname(const char* value, size_t size) {
  set_has_commandname();
  if (commandname_ == &::google::protobuf::internal::kEmptyString) {
    commandname_ = new ::std::string;
  }
  commandname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExeCommandRequest::mutable_commandname() {
  set_has_commandname();
  if (commandname_ == &::google::protobuf::internal::kEmptyString) {
    commandname_ = new ::std::string;
  }
  return commandname_;
}
inline ::std::string* ExeCommandRequest::release_commandname() {
  clear_has_commandname();
  if (commandname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = commandname_;
    commandname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExeCommandRequest::set_allocated_commandname(::std::string* commandname) {
  if (commandname_ != &::google::protobuf::internal::kEmptyString) {
    delete commandname_;
  }
  if (commandname) {
    set_has_commandname();
    commandname_ = commandname;
  } else {
    clear_has_commandname();
    commandname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FileUpload

// required string filepath = 1;
inline bool FileUpload::has_filepath() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileUpload::set_has_filepath() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileUpload::clear_has_filepath() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileUpload::clear_filepath() {
  if (filepath_ != &::google::protobuf::internal::kEmptyString) {
    filepath_->clear();
  }
  clear_has_filepath();
}
inline const ::std::string& FileUpload::filepath() const {
  return *filepath_;
}
inline void FileUpload::set_filepath(const ::std::string& value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
}
inline void FileUpload::set_filepath(const char* value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
}
inline void FileUpload::set_filepath(const char* value, size_t size) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileUpload::mutable_filepath() {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  return filepath_;
}
inline ::std::string* FileUpload::release_filepath() {
  clear_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filepath_;
    filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FileUpload::set_allocated_filepath(::std::string* filepath) {
  if (filepath_ != &::google::protobuf::internal::kEmptyString) {
    delete filepath_;
  }
  if (filepath) {
    set_has_filepath();
    filepath_ = filepath;
  } else {
    clear_has_filepath();
    filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 filepos = 2;
inline bool FileUpload::has_filepos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileUpload::set_has_filepos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileUpload::clear_has_filepos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileUpload::clear_filepos() {
  filepos_ = GOOGLE_ULONGLONG(0);
  clear_has_filepos();
}
inline ::google::protobuf::uint64 FileUpload::filepos() const {
  return filepos_;
}
inline void FileUpload::set_filepos(::google::protobuf::uint64 value) {
  set_has_filepos();
  filepos_ = value;
}

// -------------------------------------------------------------------

// Message

// optional .msg.AddCommandsRequest acr = 1;
inline bool Message::has_acr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_acr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_acr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_acr() {
  if (acr_ != NULL) acr_->::msg::AddCommandsRequest::Clear();
  clear_has_acr();
}
inline const ::msg::AddCommandsRequest& Message::acr() const {
  return acr_ != NULL ? *acr_ : *default_instance_->acr_;
}
inline ::msg::AddCommandsRequest* Message::mutable_acr() {
  set_has_acr();
  if (acr_ == NULL) acr_ = new ::msg::AddCommandsRequest;
  return acr_;
}
inline ::msg::AddCommandsRequest* Message::release_acr() {
  clear_has_acr();
  ::msg::AddCommandsRequest* temp = acr_;
  acr_ = NULL;
  return temp;
}
inline void Message::set_allocated_acr(::msg::AddCommandsRequest* acr) {
  delete acr_;
  acr_ = acr;
  if (acr) {
    set_has_acr();
  } else {
    clear_has_acr();
  }
}

// optional .msg.GetCommandsResponse gcr = 2;
inline bool Message::has_gcr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_gcr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_gcr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_gcr() {
  if (gcr_ != NULL) gcr_->::msg::GetCommandsResponse::Clear();
  clear_has_gcr();
}
inline const ::msg::GetCommandsResponse& Message::gcr() const {
  return gcr_ != NULL ? *gcr_ : *default_instance_->gcr_;
}
inline ::msg::GetCommandsResponse* Message::mutable_gcr() {
  set_has_gcr();
  if (gcr_ == NULL) gcr_ = new ::msg::GetCommandsResponse;
  return gcr_;
}
inline ::msg::GetCommandsResponse* Message::release_gcr() {
  clear_has_gcr();
  ::msg::GetCommandsResponse* temp = gcr_;
  gcr_ = NULL;
  return temp;
}
inline void Message::set_allocated_gcr(::msg::GetCommandsResponse* gcr) {
  delete gcr_;
  gcr_ = gcr;
  if (gcr) {
    set_has_gcr();
  } else {
    clear_has_gcr();
  }
}

// optional .msg.ExeCommandRequest ecr = 3;
inline bool Message::has_ecr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message::set_has_ecr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message::clear_has_ecr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message::clear_ecr() {
  if (ecr_ != NULL) ecr_->::msg::ExeCommandRequest::Clear();
  clear_has_ecr();
}
inline const ::msg::ExeCommandRequest& Message::ecr() const {
  return ecr_ != NULL ? *ecr_ : *default_instance_->ecr_;
}
inline ::msg::ExeCommandRequest* Message::mutable_ecr() {
  set_has_ecr();
  if (ecr_ == NULL) ecr_ = new ::msg::ExeCommandRequest;
  return ecr_;
}
inline ::msg::ExeCommandRequest* Message::release_ecr() {
  clear_has_ecr();
  ::msg::ExeCommandRequest* temp = ecr_;
  ecr_ = NULL;
  return temp;
}
inline void Message::set_allocated_ecr(::msg::ExeCommandRequest* ecr) {
  delete ecr_;
  ecr_ = ecr;
  if (ecr) {
    set_has_ecr();
  } else {
    clear_has_ecr();
  }
}

// optional .msg.FileUpload fu = 4;
inline bool Message::has_fu() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message::set_has_fu() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message::clear_has_fu() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message::clear_fu() {
  if (fu_ != NULL) fu_->::msg::FileUpload::Clear();
  clear_has_fu();
}
inline const ::msg::FileUpload& Message::fu() const {
  return fu_ != NULL ? *fu_ : *default_instance_->fu_;
}
inline ::msg::FileUpload* Message::mutable_fu() {
  set_has_fu();
  if (fu_ == NULL) fu_ = new ::msg::FileUpload;
  return fu_;
}
inline ::msg::FileUpload* Message::release_fu() {
  clear_has_fu();
  ::msg::FileUpload* temp = fu_;
  fu_ = NULL;
  return temp;
}
inline void Message::set_allocated_fu(::msg::FileUpload* fu) {
  delete fu_;
  fu_ = fu;
  if (fu) {
    set_has_fu();
  } else {
    clear_has_fu();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace msg

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Message_2eproto__INCLUDED
